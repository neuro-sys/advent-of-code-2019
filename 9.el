(require 'queue)

(defconst op-add 1)
(defconst op-mul 2)
(defconst op-in 3)
(defconst op-out 4)
(defconst op-jump-if-true 5)
(defconst op-jump-if-false 6)
(defconst op-less-than 7)
(defconst op-equals 8)
(defconst op-adj-rel 9)
(defconst op-end 99)

(defconst mode-position 0)
(defconst mode-immediate 1)
(defconst mode-relative 2)

(defun load-program (&optional extra-space)
  (with-temp-buffer
    (insert-file-contents "9.txt")
    (vconcat
     (mapcar 'string-to-number (split-string (buffer-string) "," t))
     (if extra-space (make-vector extra-space 0)))))

(defun decode-mode (op)
  (let ((a (% (floor (/ op 100)) 10))
        (b (% (floor (/ op 1000)) 10))
        (c (% (floor (/ op 10000)) 10)))
    (list a b c)))

(defun decode-inst (op)
  (% op 100))

;; Simplify decoder further

(defun decode-param-with-mode (memory mode param regs)
  (cond ((= mode mode-position) (elt memory param))
        ((= mode mode-relative) (elt memory (+ (nth 1 regs) param)))
        ((= mode mode-immediate) param)
        (t (throw 'invalid-mode nil))))

(defun decode-op-1-param (memory pc-sym regs)
  (let* ((pc-val (symbol-value pc-sym))
         (op (elt memory pc-val))
         (modes (decode-mode op))
         (a (elt memory (+ 1 pc-val)))
         (mode (nth 0 modes))
         (a (decode-param-with-mode memory mode a regs)))
    (list a)))

(defun decode-op-2-param (memory pc-sym regs)
  (let* ((pc-val (symbol-value pc-sym))
         (op (elt memory pc-val))
         (modes (decode-mode op))
         (a (elt memory (+ 1 pc-val)))
         (b (elt memory (+ 2 pc-val)))
         (a (decode-param-with-mode memory (nth 0 modes) a regs))
         (b (decode-param-with-mode memory (nth 1 modes) b regs)))
    (list a b)))

(defun decode-op-3-param (memory pc-sym regs)
  (let* ((pc-val (symbol-value pc-sym))
         (op (elt memory pc-val))
         (modes (decode-mode op))
         (a (elt memory (+ 1 pc-val)))
         (b (elt memory (+ 2 pc-val)))
         (c (elt memory (+ 3 pc-val)))
         (a (decode-param-with-mode memory (nth 0 modes) a regs))
         (b (decode-param-with-mode memory (nth 1 modes) b regs))
         (c (decode-param-with-mode memory (nth 2 modes) c regs)))
    (list a b c)))

(defun do-op-add (memory pc-sym regs)
  (let ((operands (decode-op-3-param memory pc-sym regs)))
    (aset memory (nth 2 operands) (+ (nth 0 operands) (nth 1 operands)))
    (set pc-sym (+ 4 (symbol-value pc-sym)))))

(defun do-op-mul (memory pc-sym regs)
  (let ((operands (decode-op-3-param memory pc-sym regs)))
    (aset memory (nth 2 operands) (* (nth 0 operands) (nth 1 operands)))
    (set pc-sym (+ 4 (symbol-value pc-sym)))))

(defun do-op-in (memory pc-sym in-buffer regs)
  (let ((operands (decode-op-1-param memory pc-sym regs))
        (b (if (queue-empty in-buffer)
               (throw 'waiting-input nil)
             (queue-dequeue in-buffer))))
    (aset memory (nth 0 operands) b))
  (set pc-sym (+ 2 (symbol-value pc-sym))))

(defun do-op-out (memory pc-sym out-buffer regs)
  (let* ((operands (decode-op-1-param memory pc-sym regs))
         (b (nth 0 operands)))
    (queue-enqueue out-buffer b))
  (set pc-sym (+ 2 (symbol-value pc-sym))))

(defun do-op-jump-if-true (memory pc-sym regs)
  (let ((operands (decode-op-2-param memory pc-sym regs)))
    (if (not (zerop (nth 0 operands)))
        (set pc-sym (nth 1 operands))
      (set pc-sym (+ 3 (symbol-value pc-sym))))))

(defun do-op-jump-if-false (memory pc-sym regs)
  (let ((operands (decode-op-2-param memory pc-sym regs)))
    (if (zerop (nth 0 operands))
        (set pc-sym (nth 1 operands))
      (set pc-sym (+ 3 (symbol-value pc-sym))))))

(defun do-op-less-than (memory pc-sym regs)
  (let ((operands (decode-op-3-param memory pc-sym regs)))
    (if (< (nth 0 operands) (nth 1 operands))
        (aset memory (nth 2 operands) 1)
      (aset memory (nth 2 operands) 0)))
  (set pc-sym (+ 4 (symbol-value pc-sym))))

(defun do-op-equals (memory pc-sym regs)
  (let ((operands (decode-op-3-param memory pc-sym regs)))
    (if (= (nth 0 operands) (nth 1 operands))
        (aset memory (nth 2 operands) 1)
      (aset memory (nth 2 operands) 0)))
  (set pc-sym (+ 4 (symbol-value pc-sym))))

(defun do-op-adj-rel (memory pc-sym regs)
  (let* ((operands (decode-op-1-param memory pc-sym regs))
         (b (nth 0 operands)))
    (setf (nth 1 regs) (+ (nth 1 regs) b)))
  (set pc-sym (+ 2 (symbol-value pc-sym))))
  
(defun int-code-create (memory in-buffer out-buffer)
  ;; :memory :in-buffer :out-buffer :memory-len :regs
  (list memory
        in-buffer
        out-buffer
        (length memory)
        ;; :pc :rel-base
        (list 0 0)))

(defun int-code-run (int-code)
  (let* ((memory (nth 0 int-code))
         (in-buffer (nth 1 int-code))
         (out-buffer (nth 2 int-code))
         (memory-length (nth 3 int-code))
         (regs (nth 4 int-code))
         (pc (nth 0 regs))
         (cur-op (decode-inst (elt memory pc))))
    (while (/= cur-op op-end)
      (cond ((= cur-op op-add) (do-op-add memory 'pc regs))
            ((= cur-op op-mul) (do-op-mul memory 'pc regs))
            ((= cur-op op-in) (do-op-in memory 'pc in-buffer regs))
            ((= cur-op op-out) (do-op-out memory 'pc out-buffer regs))
            ((= cur-op op-jump-if-true) (do-op-jump-if-true memory 'pc regs))
            ((= cur-op op-jump-if-false) (do-op-jump-if-false memory 'pc regs))
            ((= cur-op op-less-than) (do-op-less-than memory 'pc regs))
            ((= cur-op op-equals) (do-op-equals memory 'pc regs))
            ((= cur-op op-adj-rel) (do-op-adj-rel memory 'pc regs))
            (t (throw 'invalid-op-code cur-op)))
      (setf (nth 0 regs) pc)
      (setq cur-op (decode-inst (elt memory pc)))))
  t)

(let* ((in-buffer (queue-create))
       (out-buffer (queue-create))
       (int-code (int-code-create (load-program 1000) in-buffer out-buffer)))
  (queue-enqueue in-buffer 1)
  (int-code-run int-code)
  (insert (message "\n;; %S" out-buffer)))

